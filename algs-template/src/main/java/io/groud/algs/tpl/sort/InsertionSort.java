package io.groud.algs.tpl.sort;

import static io.groud.algs.tpl.sort.Sorts.comSwap;

/**
 * 插入排序
 * ———————————————————————————————————————————————————————————————————————————————
 * 总体思想：
 * 每次拿到一个元素，判断元素与前面的元素大小进行插入。
 * 每次拿到元素前面的已经是有序的
 * ———————————————————————————————————————————————————————————————————————————————
 * 代码过程：
 * - 外层循环遍历每个元素，遍历过的元素是有序的
 * - 内层循环用当前元素与前面的元素进行比较，如果比前面元素小进行替换
 * - 替换后继续向前比较（双指针距离为 1 向左移动），一旦不需要替换操作说明已经放入正确位置
 * ———————————————————————————————————————————————————————————————————————————————
 * 针对有序数组优化点：
 * - 比较替换时，如果不需要替换说明已经在正确位置，跳出此次比对
 * ———————————————————————————————————————————————————————————————————————————————
 * 属性：
 * - 稳定
 * - O(1) 空间
 * - O(n^2) 操作替换
 * - 适应性: O(n) 时间复杂度，几乎排序时
 * - 非常低的开销
 *
 * @author Li.Wei by 2020/3/7
 */
public class InsertionSort implements Sort {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] a) {
        int length = a.length;
        int i = 1;
        while (i < length) {
            int curr = i;
            while (curr > 0) {
                // 当前值 < 前面的值进行替换，如果无需进行替换，说明已经在正确位置
                if (!comSwap(a, curr - 1, curr)) break;
                curr--; // 左移指针，准备进行下一次比较插入
            }
            i++; // 指向下一个待插入的元素
        }
        return a;
    }
}
